// This file is @generated by prost-build.
/// token pair
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPair {
    #[prost(message, optional, tag = "1")]
    pub token0: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "2")]
    pub token1: ::core::option::Option<super::common::CanisterId>,
}
/// token pair
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPairAmm {
    #[prost(message, optional, tag = "1")]
    pub pair: ::core::option::Option<TokenPair>,
    #[prost(string, tag = "2")]
    pub amm: ::prost::alloc::string::String,
}
/// create
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairCreate {
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    #[prost(message, optional, tag = "2")]
    pub creator: ::core::option::Option<super::common::UserId>,
}
/// swap
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairSwapToken {
    /// which token pair, token_a -> token_b
    #[prost(message, optional, tag = "1")]
    pub token_a: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "2")]
    pub token_b: ::core::option::Option<super::common::CanisterId>,
    #[prost(string, tag = "3")]
    pub amm: ::prost::alloc::string::String,
    /// account pay
    #[prost(message, optional, tag = "4")]
    pub from: ::core::option::Option<super::common::Account>,
    /// account got
    #[prost(message, optional, tag = "5")]
    pub to: ::core::option::Option<super::common::Account>,
    /// amount pay
    #[prost(message, optional, tag = "6")]
    pub amount_a: ::core::option::Option<super::common::Nat>,
    /// amount got
    #[prost(message, optional, tag = "7")]
    pub amount_b: ::core::option::Option<super::common::Nat>,
}
/// cumulative price
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairCumulativePrice {
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    #[prost(uint64, tag = "2")]
    pub block_timestamp: u64,
    #[prost(uint32, tag = "3")]
    pub price_cumulative_exponent: u32,
    #[prost(message, optional, tag = "4")]
    pub price0_cumulative: ::core::option::Option<super::common::Nat>,
    #[prost(message, optional, tag = "5")]
    pub price1_cumulative: ::core::option::Option<super::common::Nat>,
}
/// mint
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapV2MintToken {
    /// which token pair
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    /// from account
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<super::common::Account>,
    /// token transfer in
    #[prost(message, optional, tag = "3")]
    pub token0: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "4")]
    pub token1: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "5")]
    pub amount0: ::core::option::Option<super::common::Nat>,
    #[prost(message, optional, tag = "6")]
    pub amount1: ::core::option::Option<super::common::Nat>,
    /// lp token mint
    #[prost(message, optional, tag = "7")]
    pub token: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "8")]
    pub amount: ::core::option::Option<super::common::Nat>,
    /// to account
    #[prost(message, optional, tag = "9")]
    pub to: ::core::option::Option<super::common::Account>,
}
/// burn
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapV2BurnToken {
    /// which token pair
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    /// from account
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<super::common::Account>,
    /// lp token burn
    #[prost(message, optional, tag = "3")]
    pub token: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "4")]
    pub amount: ::core::option::Option<super::common::Nat>,
    /// token transfer out
    #[prost(message, optional, tag = "5")]
    pub token0: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "6")]
    pub token1: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "7")]
    pub amount0: ::core::option::Option<super::common::Nat>,
    #[prost(message, optional, tag = "8")]
    pub amount1: ::core::option::Option<super::common::Nat>,
    /// to account
    #[prost(message, optional, tag = "9")]
    pub to: ::core::option::Option<super::common::Account>,
    /// maybe fee
    #[prost(message, optional, tag = "10")]
    pub fee: ::core::option::Option<super::common::BurnFee>,
}
/// mint fee
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapV2MintFeeToken {
    /// which token pair
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    /// lp token mint
    #[prost(message, optional, tag = "2")]
    pub token: ::core::option::Option<super::common::CanisterId>,
    #[prost(message, optional, tag = "3")]
    pub amount: ::core::option::Option<super::common::Nat>,
    /// to account
    #[prost(message, optional, tag = "4")]
    pub to: ::core::option::Option<super::common::Account>,
}
/// transfer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapV2TransferToken {
    /// which token pair
    #[prost(message, optional, tag = "1")]
    pub pa: ::core::option::Option<TokenPairAmm>,
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<super::common::Account>,
    #[prost(message, optional, tag = "3")]
    pub amount: ::core::option::Option<super::common::Nat>,
    #[prost(message, optional, tag = "4")]
    pub to: ::core::option::Option<super::common::Account>,
    #[prost(message, optional, tag = "5")]
    pub fee: ::core::option::Option<super::common::TransferFee>,
}
/// swap v2 operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapV2Operation {
    #[prost(oneof = "swap_v2_operation::SwapV2Operation", tags = "1, 2, 3, 4, 5")]
    pub swap_v2_operation: ::core::option::Option<swap_v2_operation::SwapV2Operation>,
}
/// Nested message and enum types in `SwapV2Operation`.
pub mod swap_v2_operation {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SwapV2Operation {
        #[prost(message, tag = "1")]
        CumulativePrice(super::PairCumulativePrice),
        #[prost(message, tag = "2")]
        Mint(super::SwapV2MintToken),
        #[prost(message, tag = "3")]
        Burn(super::SwapV2BurnToken),
        #[prost(message, tag = "4")]
        MintFee(super::SwapV2MintFeeToken),
        #[prost(message, tag = "5")]
        Transfer(super::SwapV2TransferToken),
    }
}
/// pair operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairOperation {
    #[prost(oneof = "pair_operation::PairOperation", tags = "1, 2, 10")]
    pub pair_operation: ::core::option::Option<pair_operation::PairOperation>,
}
/// Nested message and enum types in `PairOperation`.
pub mod pair_operation {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PairOperation {
        #[prost(message, tag = "1")]
        Create(super::PairCreate),
        #[prost(message, tag = "2")]
        Swap(super::PairSwapToken),
        /// swap v2
        ///
        /// start at 10
        #[prost(message, tag = "10")]
        SwapV2(super::SwapV2Operation),
    }
}
/// operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapOperation {
    #[prost(oneof = "swap_operation::SwapOperation", tags = "1")]
    pub swap_operation: ::core::option::Option<swap_operation::SwapOperation>,
}
/// Nested message and enum types in `SwapOperation`.
pub mod swap_operation {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SwapOperation {
        #[prost(message, tag = "1")]
        Pair(super::PairOperation),
    }
}
/// transaction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapTransaction {
    #[prost(message, optional, tag = "1")]
    pub operation: ::core::option::Option<SwapOperation>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub memo: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "3")]
    pub created: ::core::option::Option<u64>,
}
/// SwapBlock
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapBlock {
    #[prost(message, optional, tag = "1")]
    pub parent_hash: ::core::option::Option<super::common::Hash>,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    #[prost(message, optional, tag = "3")]
    pub transaction: ::core::option::Option<SwapTransaction>,
}
